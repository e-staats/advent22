ðŸ’»ðŸŽ„ðŸ’» Advent of Code 2022 ðŸ’»ðŸŽ„ðŸ’»
=================================

This year, I'm using the AoC puzzles as a chance to learn Go and get some practice with it. I'll be using this Readme as a blog of sorts about the experience.

**Day 1:** I started out with the [Getting Started](https://go.dev/doc/tutorial/getting-started) page and then moved on to the [Tour of Go](https://go.dev/tour/). I was already familiar with C at a high level, so this wasn't too crazy. I liked that there are a few more things built in than C. I had a little trouble wrapping my head around the go.mod files and the ways packages export functions and how you call them from other functions. I thought I might use like a "utilities" library for the puzzles as times goes on, but opted just to do one folder per day and have a main package in each. The puzzle itself was pretty simple, but I did have to go searching for the file reading APIs in Go. I was happy to see that they were pretty straightforward.

**Day 2:** I used an slice of slices to make myself a matrix, and I got a little more familiar with the 'strings' library. I particularly liked my solution to part 2, where I made a matrix of strategies that told me what to play depending on the outcome we wanted.

**Day 3:** I spent a silly amount of time trying to find the bufio API that would let me manually step through the lines of a text file before realizing that that's what the scanner.Scan() in the for loop did. I don't know if this is totally necessary or not, but I ended up grabbing an external library to make it easy to get the keys of a map in an array. I miss Python :(

**Day 4:** Not a ton to say about this one; string manipulation is a little more verbose in Go compared to Python, and I miss list comprehensions. The biggest road block was me misreading the prompt and returning the number of pairs with no overlap instead of the number of pairs with overlap in part 2.

**Day 5:** A little bit of a thinker! I pretty quickly came to understand that this was about popping and pushing values onto stacks (thanks to the puzzle literally using stacks as the flavor). That led me to realize that I either needed to implement my own Stack 'class' in Go, find someone who already did and import it, or hack together an approximation of a stack with the array/slice built-ins. I opted to use someone elses implementation because I'm lazy, and I was a little surprised to find that there wasn't a standard one that everybody uses. Does everyone who needs a stack in Go write their own? Or copy the same answer off Stack Overflow every time? It seems weird to me that there's not a pseudo-standard collections package that gives you all the Stack, Queue, etc stuff you might want. That's one thing that I love about Python. I ended up using [CookieJar](https://github.com/karalabe/cookiejar), which seems like it was created for programming competitions. Very strange.

Anyways, the actual puzzle was pretty fun. I liked my solution to parsing the input image of pushing each line onto a stack as I read it, then popping the lines off populate the individual stacks. That made it easy to account for the varying heights of the stacks. The other gotcha was remembering to decrement the source and target indices in the instructions to line up with my array of stacks.

**Day 6:** Yeehaw, the first puzzle where part 2 puts your algorithm to the test. I decided to try and see how well I could do on the leaderboard on this one, understanding that it was very unlikely to be good when I'm using a language I'm still pretty unfamiliar with. And indeed, it took me about 45 minutes, about half of which was fiddling with language stuff, and half of which was rethinking my approach to the puzzle. I initially started trying to use a Queue 'object' as my buffer because I didn't trust how much I could do with the built-in slices. Then I saw that removing the first element of a slice is actually very easy with append, and I went back to a raw slice of runes. Then when trying to figure out if the buffer had duplicates in it, I tried to implement that without an additional data structure and toggle a variable back and forth if there were duplicates. But because of the process of filling up the buffer at the start, I had trouble getting that to work, and I ended up creating a map of characters with the counts of how many times I'd seen them. When adding a character to the end of the buffer, I incremented the seen counter, and when removing a character from the front of the queue, I decremented the seen counter. When every rune in the queue had a seen count of <2, I knew I had a sequence of unique characters. I was happy to see my part 2 perform well; I timed it and saw Part 1 took 208Âµs and Part 2 took 470Âµs, which makes sense. Go is fast!

On a side note, I still don't have a good way of not duplicating code when creating part 2 from part 1. I've just been copying and pasting the entire function from part 1 to part 2, which feels like a waste.

...

**Day 10:** I missed a few days, and so I was relieved to see that this puzzle wasn't too crazy. I'm sure my solution could be more elegant (I have 5 variables for tracking state during the loop), but it worked! I was intimidated reading part 2, but it was pretty straightforward to implement. My comparison to determine the pixel to print is not quiiiite right, I don't think (it doesn't print anything on the 40th column ever), but it's right enough to decipher the letters.

**Day 11:** Upon first reading, my eyes galzed over a bit at all the steps involved, but when I took a second run through it, it was more clear that step one was to create an array of Monkey objects, and then step two was to run a loop and simulate what these ridiculous monkeys do. That first step was a bit of a challenge, since I haven't used Go for OOP yet. It wasn't super challenging to get started with, and the hardest part was parsing the text of the input into each Monkey object. Because of all the strong typing and the error return values from the type conversion functions, it ended up being pretty verbose. It's still very easy to use, though, and I learned about a few more common functions from the strings library. Once I got the monkeys created, simulating the loop was pretty straightforward.

For part 2, I did the naive thing of deleting the divide by 3, increasing the loop stop to 10,000, and then hitting run. To Go's credit, it still ran in a few hundred milliseconds (with all the printing I was doing), but the answer was not right. I pasted the sample input back in and checked it against the guardrails in part 2, and I saw that I was bang on for the first couple cycles but diverged by cycle 1000. Also, I was getting some really big numbers in each monkey's inventory, and some of them were...negative. Ah yeah, I forgot that numbers can get too big. I poked around with the 'big' library, but it was a pain to convert my existing code to BigInts, and partway through I realized that the scale of the numbers was probably going to be too big even for big int. So when I realize numbers are too big and all I'm really doing is testing divisibility, that makes me think about the magic properties of modulo. I guess and checked a bit with knocking each number down to the modulo of the test value before sending it to the next monkey, but that pretty clearly wasn't right. I thought about it a bit more, and I realized that the property I was looking to preserve was the divisibility by all the monkeys, so what if I multiplied all those together, and then modulo'd the worry value whenever it got over that value? And lo and behold, that worked! This one was fun, even if it was a bit of a challenge!